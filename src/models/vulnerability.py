# -*- coding: utf-8 -*-
from .cvss import CVSS
from .package import Package


class Vulnerability:
    """
    Vulnerability class used to represent a generic vuln from CVE, OSV, GHSA, ...
    A vulnerability can affect one or more packages.
    A vulnerability can have severity and/or CVSS scores.
    Fix and Impacted version are not handled yet.
    """

    def __init__(self, id: str, found_by: str, datasource: str, namespace: str):
        """
        Create a new Vulnerability with at least then given id.
        Can include information about scanner, datasource used for find and namespace for id.
        """
        self.id = id.upper()
        """
        Unique identifier for this vulnerability.
        Usually CVE-YEAR-NUMBER, OSV-YYYY-NNNN or GHSA-XXXX-YYYY-ZZZZ.
        """
        self.found_by = found_by
        """Scanner or tool that found this vulnerability in our product/source code."""
        self.datasource = datasource
        """
        Source of the data for this vulnerability.
        Usually the name of the database or API used by the scanner to match.
        """
        self.namespace = namespace
        """
        Namespace for the id of this vulnerability.
        Usually the name of the database or API used by the scanner to match.
        """
        self.aliases = []
        """List of other ids that are aliases for this vulnerability."""
        self.related_vulnerabilities = []
        """List of other vulnerabilities that are related to this one but not the same."""
        self.urls = []
        """List of URLs as reference for this vulnerability."""
        self.texts = {}
        """
        Dictionary of texts related to this vulnerability with document title as key.
        Can be summary, description, ...
        """
        # fix and impacted version are not available yet.
        # regex for later use : _regex_version = r"\s*^([<>=!][=]?)?\s*([\d\.a-zA-Z\-]+)[^\n]*$"
        self.fix = {
            "versions_impacted": [],
            "versions_fixing": [],
            "state": "unknown",
        }
        self.severity = {
            "severity": "unknown",
            "min_score": None,
            "max_score": None,
            "cvss": [],
        }
        self.advisories = []
        """List of advisory references for this vulnerability."""
        self.packages = []
        """List of packages affected by this vulnerability."""

    def add_alias(self, alias: str):
        """Register another id as an alias for this vulnerability."""
        if alias.upper() not in self.aliases and alias.upper() != self.id:
            self.aliases.append(alias.upper())

    def add_related_vulnerability(self, related_vuln: str):
        """Register another vulnerability as related but not the same to this one."""
        if related_vuln not in self.related_vulnerabilities:
            self.related_vulnerabilities.append(related_vuln)

    def add_url(self, url: str):
        """add an URL as reference for this vulnerability."""
        if url not in self.urls:
            self.urls.append(url)

    def add_text(self, text: str, as_ref: str):
        """Add a summary, description or any text related to this vulnerability."""
        if as_ref not in self.texts:
            self.texts[as_ref] = text
        else:
            self.texts[as_ref] += "\n\n" + text

    def set_fix_state(self, state: str):
        """Set the state of the fix for this vulnerability."""
        self.fix["state"] = state

    def register_cvss(self, cvss_score: CVSS):
        """Register a CVSS score for this vulnerability, setting severity data on the way."""
        if cvss_score not in self.severity["cvss"]:
            self.severity["cvss"].append(cvss_score)
            if self.severity["min_score"] is None or cvss_score.base_score < self.severity["min_score"]:
                self.severity["min_score"] = cvss_score.base_score
            if self.severity["max_score"] is None or cvss_score.base_score > self.severity["max_score"]:
                self.severity["max_score"] = cvss_score.base_score
                self.severity["severity"] = cvss_score.severity().lower()

    def severity_without_cvss(self, severity: str, score: float = None, force_replace: bool = False):
        """Set the severity of this vulnerability without a CVSS score."""
        if self.severity["severity"] == "unknown" or force_replace:
            self.severity["severity"] = severity.lower()
        if score is not None:
            if self.severity["min_score"] is None or score < self.severity["min_score"]:
                self.severity["min_score"] = score
            if self.severity["max_score"] is None or score > self.severity["max_score"]:
                self.severity["max_score"] = score
                if severity.lower() != "unknown":
                    self.severity["severity"] = severity.lower()

    def add_advisory(self, advisory: str):
        """Add an advisory reference to this vulnerability."""
        if advisory not in self.advisories:
            self.advisories.append(advisory)

    def add_package(self, package) -> bool:
        """
        Add a package to the list of packages affected by this vulnerability.
        Can be a string or a Package object.
        Return True if the package was added, False if it was already in the list or invalid.
        """
        if isinstance(package, str):
            if package not in self.packages:
                self.packages.append(package)
                return True
        elif isinstance(package, Package):
            if package.id not in self.packages:
                self.packages.append(package.id)
                return True
        return False

    def __contains__(self, package: str) -> bool:
        """Check if a package is in the list of packages affected by this vulnerability."""
        return package in self.packages

    def to_dict(self) -> dict:
        """Return a dict representation of this vulnerability."""
        return {
            "id": self.id,
            "found_by": self.found_by,
            "datasource": self.datasource,
            "namespace": self.namespace,
            "aliases": self.aliases,
            "related_vulnerabilities": self.related_vulnerabilities,
            "urls": self.urls,
            "texts": self.texts,
            "fix": self.fix,
            "severity": {
                "severity": self.severity["severity"],
                "min_score": self.severity["min_score"],
                "max_score": self.severity["max_score"],
                "cvss": [cvss.to_dict() if isinstance(cvss, CVSS) else cvss for cvss in self.severity["cvss"]]
            },
            "advisories": self.advisories,
            "packages": self.packages
        }

    def from_dict(data: dict):
        """Create a new Vulnerability object from a dict."""
        item = Vulnerability(data["id"], data["found_by"], data["datasource"], data["namespace"])
        item.aliases = data["aliases"]
        item.related_vulnerabilities = data["related_vulnerabilities"]
        item.urls = data["urls"]
        item.texts = data["texts"]
        item.fix = data["fix"]
        item.severity = {
            "severity": data["severity"]["severity"],
            "min_score": data["severity"]["min_score"],
            "max_score": data["severity"]["max_score"],
            "cvss": [CVSS.from_dict(cvss) if isinstance(cvss, dict) else cvss for cvss in data["severity"]["cvss"]]
        }
        item.advisories = data["advisories"]
        item.packages = data["packages"]
        return item

    def merge(self, other) -> bool:
        """
        Merge another vulnerability into this one.
        Return True if the merge was successful, False if the two vulnerabilities are not compatible.
        """
        is_alias = False
        if self.id == other.id or self.id in other.aliases or other.id in self.aliases:
            is_alias = True
        else:
            for alias in self.aliases:
                if alias in other.aliases:
                    is_alias = True
                    break
            for alias in other.aliases:
                if alias in self.aliases:
                    is_alias = True
                    break

        if not is_alias:
            return False

        self.add_alias(other.id)
        for alias in other.aliases:
            self.add_alias(alias)
        for related in other.related_vulnerabilities:
            self.add_related_vulnerability(related)
        for url in other.urls:
            self.add_url(url)

        for title in other.texts:
            if self.texts.get(title) == other.texts[title]:
                continue
            text_already_present = False
            for key in self.texts:
                if self.texts[key] == other.texts[title]:
                    text_already_present = True
            if text_already_present:
                continue

            new_key = title
            tmp_inc = 2
            while new_key in self.texts:
                new_key = title + "_" + str(tmp_inc)
                tmp_inc += 1
            self.add_text(other.texts[title], new_key)

        for adv in other.advisories:
            self.add_advisory(adv)
        for p in other.packages:
            self.add_package(p)

        for cvss in other.severity["cvss"]:
            self.register_cvss(cvss)
        if other.severity["min_score"] is not None:
            if self.severity["min_score"] is None or other.severity["min_score"] < self.severity["min_score"]:
                self.severity["min_score"] = other.severity["min_score"]

        if other.severity["max_score"] is not None:
            if self.severity["max_score"] is None or other.severity["max_score"] > self.severity["max_score"]:
                self.severity["max_score"] = other.severity["max_score"]

                if other.severity["severity"] != "unknown":
                    self.severity["severity"] = other.severity["severity"]

        if other.fix["state"] != "unknown" and self.fix["state"] == "unknown":
            self.fix["state"] = other.fix["state"]
        return True
