# -*- coding: utf-8 -*-
from .cvss import CVSS
from .package import Package
from .iso8601_duration import Iso8601Duration


class Vulnerability:
    """
    Vulnerability class used to represent a generic vuln from CVE, OSV, GHSA, ...
    A vulnerability can affect one or more packages.
    A vulnerability can have severity and/or CVSS scores.
    Fix and Impacted version are not handled yet.
    """

    def __init__(self, id: str, found_by: list, datasource: str, namespace: str):
        """
        Create a new Vulnerability with at least then given id.
        Can include information about scanner, datasource used for find and namespace for id.
        """
        self.id = id.upper()
        """
        Unique identifier for this vulnerability.
        Usually CVE-YEAR-NUMBER, OSV-YYYY-NNNN or GHSA-XXXX-YYYY-ZZZZ.
        """
        self.found_by = []
        for scanner in found_by:
            self.add_found_by(scanner)
        """Scanners or tools that found this vulnerability in our product/source code."""

        self.datasource = datasource
        """
        Source of the data for this vulnerability.
        Usually the name of the database or API used by the scanner to match.
        """
        self.namespace = namespace
        """
        Namespace for the id of this vulnerability.
        Usually the name of the database or API used by the scanner to match.
        """
        self.aliases = []
        """List of other ids that are aliases for this vulnerability."""
        self.related_vulnerabilities = []
        """List of other vulnerabilities that are related to this one but not the same."""
        self.urls = []
        """List of URLs as reference for this vulnerability."""
        self.texts = {}
        """
        Dictionary of texts related to this vulnerability with document title as key.
        Can be summary, description, ...
        """
        # fix and impacted version are not available yet.
        # regex for later use : _regex_version = r"\s*^([<>=!][=]?)?\s*([\d\.a-zA-Z\-]+)[^\n]*$"
        self.fix = {
            "versions_impacted": [],
            "versions_fixing": [],
            "state": "unknown",
        }
        self.severity = {
            "severity": "unknown",
            "min_score": None,
            "max_score": None,
            "cvss": [],
        }
        """
        Metadata about severity of the vuln, using classic CVSS
        but also support severity+score from external scoring systems.
        """
        self.epss = {
            "score": None,
            "percentile": None,
        }
        """
        EPSS metrics representing the score [0-1] of probability of exploit being used
        and percentile to rank against others vuln.
        """
        self.effort = {
            "optimistic": None,
            "likely": None,
            "pessimistic": None,
        }
        """
        Effort metrics representing the time to fix the vulnerability.
        3 values for optimistic, likely and pessimistic time to fix.
        Is either None or an instance of Iso8601Duration.
        """
        self.advisories = []
        """List of advisory references for this vulnerability."""
        self.packages = []
        """List of packages affected by this vulnerability."""

    def add_alias(self, alias: str):
        """Register another id as an alias for this vulnerability."""
        if alias.upper() not in self.aliases and alias.upper() != self.id:
            self.aliases.append(alias.upper())

    def add_related_vulnerability(self, related_vuln: str):
        """Register another vulnerability as related but not the same to this one."""
        if related_vuln not in self.related_vulnerabilities:
            self.related_vulnerabilities.append(related_vuln)

    def add_url(self, url: str):
        """add an URL as reference for this vulnerability."""
        if url not in self.urls:
            self.urls.append(url)

    def add_found_by(self, scanner: str):
        """Add a scanner to the list of scanners that found this vulnerability."""
        if scanner and scanner not in self.found_by:
            self.found_by.append(scanner)

    def add_text(self, text: str, as_ref: str):
        """Add a summary, description or any text related to this vulnerability."""
        if as_ref not in self.texts:
            self.texts[as_ref] = text
        else:
            self.texts[as_ref] += "\n\n" + text

    def set_fix_state(self, state: str):
        """Set the state of the fix for this vulnerability."""
        self.fix["state"] = state

    def register_cvss(self, cvss_score: CVSS):
        """Register a CVSS score for this vulnerability, setting severity data on the way."""
        if cvss_score not in self.severity["cvss"]:
            for cvss in self.severity["cvss"]:
                if cvss.base_score == cvss_score.base_score and cvss.version == cvss_score.version:
                    if cvss.author == "" or cvss.author == "unknown":
                        cvss.author = cvss_score.author
                    if cvss.vector_string == "" or cvss.vector_string == "unknown":
                        cvss.vector_string = cvss_score.vector_string
                    if cvss.exploitability_score == 0.0:
                        cvss.exploitability_score = cvss_score.exploitability_score
                    if cvss.impact_score == 0.0:
                        cvss.impact_score = cvss_score.impact_score
                    return

            self.severity["cvss"].append(cvss_score)
            if self.severity["min_score"] is None or cvss_score.base_score < self.severity["min_score"]:
                self.severity["min_score"] = cvss_score.base_score
            if self.severity["max_score"] is None or cvss_score.base_score > self.severity["max_score"]:
                self.severity["max_score"] = cvss_score.base_score
                self.severity["severity"] = cvss_score.severity().lower()

    def severity_without_cvss(self, severity: str, score: float = None, force_replace: bool = False):
        """Set the severity of this vulnerability without a CVSS score."""
        if self.severity["severity"] == "unknown" or force_replace:
            self.severity["severity"] = severity.lower()
        if score is not None:
            if self.severity["min_score"] is None or score < self.severity["min_score"]:
                self.severity["min_score"] = score
            if self.severity["max_score"] is None or score > self.severity["max_score"]:
                self.severity["max_score"] = score
                if severity.lower() != "unknown":
                    self.severity["severity"] = severity.lower()

    def set_epss(self, score: float, percentile: float):
        """Set the EPSS metrics for this vulnerability."""
        self.epss["score"] = score
        self.epss["percentile"] = percentile

    def set_effort(self, optimistic: str, likely: str, pessimistic: str) -> bool:
        """Set the effort metrics for this vulnerability."""
        try:
            optimistic = Iso8601Duration(optimistic)
            likely = Iso8601Duration(likely)
            pessimistic = Iso8601Duration(pessimistic)
            if optimistic > likely or likely > pessimistic:
                return False
            self.effort["optimistic"] = optimistic
            self.effort["likely"] = likely
            self.effort["pessimistic"] = pessimistic
            return True
        except Exception:
            return False

    def add_advisory(self, advisory: str):
        """Add an advisory reference to this vulnerability."""
        if advisory not in self.advisories:
            self.advisories.append(advisory)

    def add_package(self, package) -> bool:
        """
        Add a package to the list of packages affected by this vulnerability.
        Can be a string or a Package object.
        Return True if the package was added, False if it was already in the list or invalid.
        """
        if isinstance(package, str):
            if package not in self.packages:
                self.packages.append(package)
                return True
        elif isinstance(package, Package):
            if package.id not in self.packages:
                self.packages.append(package.id)
                return True
        return False

    def __contains__(self, package: str) -> bool:
        """Check if a package is in the list of packages affected by this vulnerability."""
        return package in self.packages

    def to_dict(self) -> dict:
        """Return a dict representation of this vulnerability."""
        return {
            "id": self.id,
            "found_by": self.found_by,
            "datasource": self.datasource,
            "namespace": self.namespace,
            "aliases": self.aliases,
            "related_vulnerabilities": self.related_vulnerabilities,
            "urls": self.urls,
            "texts": self.texts,
            "fix": self.fix,
            "severity": {
                "severity": self.severity["severity"],
                "min_score": self.severity["min_score"],
                "max_score": self.severity["max_score"],
                "cvss": [cvss.to_dict() if isinstance(cvss, CVSS) else cvss for cvss in self.severity["cvss"]]
            },
            "epss": {
                "score": self.epss["score"],
                "percentile": self.epss["percentile"],
            },
            "effort": {
                "optimistic": None if self.effort["optimistic"] is None else str(self.effort["optimistic"]),
                "likely": None if self.effort["likely"] is None else str(self.effort["likely"]),
                "pessimistic": None if self.effort["pessimistic"] is None else str(self.effort["pessimistic"]),
            },
            "advisories": self.advisories,
            "packages": self.packages
        }

    @staticmethod
    def from_dict(data: dict):
        """Create a new Vulnerability object from a dict."""
        found_by = data["found_by"] if type(data["found_by"]) is list else [data["found_by"]]
        item = Vulnerability(data["id"], found_by, data["datasource"], data["namespace"])
        item.aliases = data["aliases"]
        item.related_vulnerabilities = data["related_vulnerabilities"]
        item.urls = data["urls"]
        item.texts = data["texts"]
        item.fix = data["fix"]
        if "severity" in data:
            item.severity = {
                "severity": data["severity"]["severity"],
                "min_score": data["severity"]["min_score"],
                "max_score": data["severity"]["max_score"],
                "cvss": [CVSS.from_dict(cvss) if isinstance(cvss, dict) else cvss for cvss in data["severity"]["cvss"]]
            }
        if "epss" in data:
            item.epss = {
                "score": data["epss"]["score"],
                "percentile": data["epss"]["percentile"],
            }
        if "effort" in data:
            eff = data["effort"]
            item.set_effort(eff["optimistic"], eff["likely"], eff["pessimistic"])
        item.advisories = data["advisories"]
        item.packages = data["packages"]
        return item

    def merge(self, other) -> bool:
        """
        Merge another vulnerability into this one.
        Return True if the merge was successful, False if the two vulnerabilities are not compatible.
        """
        is_alias = False
        if self.id == other.id or self.id in other.aliases or other.id in self.aliases:
            is_alias = True
        else:
            for alias in self.aliases:
                if alias in other.aliases:
                    is_alias = True
                    break
            for alias in other.aliases:
                if alias in self.aliases:
                    is_alias = True
                    break

        if not is_alias:
            return False

        self.add_alias(other.id)
        for alias in other.aliases:
            self.add_alias(alias)
        for related in other.related_vulnerabilities:
            self.add_related_vulnerability(related)
        for url in other.urls:
            self.add_url(url)
        for found_by in other.found_by:
            self.add_found_by(found_by)

        for title in other.texts:
            if self.texts.get(title) == other.texts[title]:
                continue
            text_already_present = False
            for key in self.texts:
                if self.texts[key] == other.texts[title]:
                    text_already_present = True
            if text_already_present:
                continue

            new_key = title
            tmp_inc = 2
            while new_key in self.texts:
                new_key = title + "_" + str(tmp_inc)
                tmp_inc += 1
            self.add_text(other.texts[title], new_key)

        for adv in other.advisories:
            self.add_advisory(adv)
        for p in other.packages:
            self.add_package(p)

        if other.datasource != "unknown" and self.datasource == "unknown":
            self.datasource = other.datasource
        elif other.datasource.startswith("http") and not self.datasource.startswith("http"):
            self.datasource = other.datasource

        for cvss in other.severity["cvss"]:
            self.register_cvss(cvss)
        if other.severity["min_score"] is not None:
            if self.severity["min_score"] is None or other.severity["min_score"] < self.severity["min_score"]:
                self.severity["min_score"] = other.severity["min_score"]

        if other.severity["max_score"] is not None:
            if self.severity["max_score"] is None or other.severity["max_score"] > self.severity["max_score"]:
                self.severity["max_score"] = other.severity["max_score"]

                if other.severity["severity"] != "unknown":
                    self.severity["severity"] = other.severity["severity"]

        if other.epss["score"] is not None:
            if self.epss["score"] is None or other.epss["score"] > self.epss["score"]:
                self.epss["score"] = other.epss["score"]
                self.epss["percentile"] = other.epss["percentile"]

        if (other.effort["optimistic"] is not None
           and other.effort["likely"] is not None
           and other.effort["pessimistic"] is not None):

            if self.effort["optimistic"] < other.effort["optimistic"]:
                self.effort["optimistic"] = other.effort["optimistic"]

            if self.effort["likely"] < other.effort["likely"]:
                self.effort["likely"] = other.effort["likely"]

            if self.effort["pessimistic"] < other.effort["pessimistic"]:
                self.effort["pessimistic"] = other.effort["pessimistic"]

        if other.fix["state"] != "unknown" and self.fix["state"] == "unknown":
            self.fix["state"] = other.fix["state"]
        return True
